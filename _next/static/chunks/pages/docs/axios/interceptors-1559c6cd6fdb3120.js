(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[732],{5208:function(e,r,t){"use strict";t.d(r,{Z:function(){return z}});var s=t(7294),n=t(3857),o=t(8067),i=(0,o.k)(((e,{radius:r,shadow:t,withBorder:s})=>({root:{outline:0,WebkitTapHighlightColor:"transparent",display:"block",textDecoration:"none",color:"dark"===e.colorScheme?e.colors.dark[0]:e.black,backgroundColor:"dark"===e.colorScheme?e.colors.dark[7]:e.white,boxSizing:"border-box",borderRadius:e.fn.radius(r),boxShadow:e.shadows[t]||t||"none",border:s?`1px solid ${"dark"===e.colorScheme?e.colors.dark[6]:e.colors.gray[2]}`:void 0}}))),a=t(1267),c=Object.defineProperty,p=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,d=(e,r,t)=>r in e?c(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t;const h={},m=(0,s.forwardRef)(((e,r)=>{const t=(0,n.Z3)("Paper",h,e),{component:o,className:c,children:m,radius:f,withBorder:x,shadow:g}=t,v=((e,r)=>{var t={};for(var s in e)l.call(e,s)&&r.indexOf(s)<0&&(t[s]=e[s]);if(null!=e&&p)for(var s of p(e))r.indexOf(s)<0&&u.call(e,s)&&(t[s]=e[s]);return t})(t,["component","className","children","radius","withBorder","shadow"]),{classes:b,cx:w}=i({radius:f,shadow:g,withBorder:x},{name:"Paper"});return s.createElement(a.x,((e,r)=>{for(var t in r||(r={}))l.call(r,t)&&d(e,t,r[t]);if(p)for(var t of p(r))u.call(r,t)&&d(e,t,r[t]);return e})({component:o||"div",className:w(b.root,c),ref:r},v),m)}));m.displayName="@mantine/core/Paper";var f=(0,o.k)(((e,{padding:r,first:t,last:s})=>({cardSection:{display:"block",marginLeft:-1*e.fn.size({size:r,sizes:e.spacing}),marginRight:-1*e.fn.size({size:r,sizes:e.spacing}),marginTop:t?-1*e.fn.size({size:r,sizes:e.spacing}):void 0,marginBottom:s?-1*e.fn.size({size:r,sizes:e.spacing}):void 0}}))),x=Object.defineProperty,g=Object.getOwnPropertySymbols,v=Object.prototype.hasOwnProperty,b=Object.prototype.propertyIsEnumerable,w=(e,r,t)=>r in e?x(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t;const k=(0,s.forwardRef)(((e,r)=>{var t=e,{className:n,padding:o=0,component:i,first:c,last:p}=t,l=((e,r)=>{var t={};for(var s in e)v.call(e,s)&&r.indexOf(s)<0&&(t[s]=e[s]);if(null!=e&&g)for(var s of g(e))r.indexOf(s)<0&&b.call(e,s)&&(t[s]=e[s]);return t})(t,["className","padding","component","first","last"]);const{classes:u,cx:d}=f({padding:o,first:c,last:p},{name:"Card"});return s.createElement(a.x,((e,r)=>{for(var t in r||(r={}))v.call(r,t)&&w(e,t,r[t]);if(g)for(var t of g(r))b.call(r,t)&&w(e,t,r[t]);return e})({component:i||"div",className:d(u.cardSection,n),ref:r},l))}));k.displayName="@mantine/core/CardSection";var y=(0,o.k)((e=>({root:{position:"relative",overflow:"hidden",backgroundColor:"dark"===e.colorScheme?e.colors.dark[6]:e.white}}))),j=Object.defineProperty,I=Object.getOwnPropertySymbols,A=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable,R=(e,r,t)=>r in e?j(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t;const q={p:"md"},z=(0,s.forwardRef)(((e,r)=>{const t=(0,n.Z3)("Card",q,e),{component:o,className:i,p:a,radius:c,children:p,classNames:l,styles:u}=t,d=((e,r)=>{var t={};for(var s in e)A.call(e,s)&&r.indexOf(s)<0&&(t[s]=e[s]);if(null!=e&&I)for(var s of I(e))r.indexOf(s)<0&&P.call(e,s)&&(t[s]=e[s]);return t})(t,["component","className","p","radius","children","classNames","styles"]),{classes:h,cx:f}=y(null,{name:"Card",classNames:l,styles:u}),x=s.Children.toArray(p),g=x.map(((e,r)=>"object"===typeof e&&e&&"type"in e&&e.type===k?(0,s.cloneElement)(e,{padding:a,first:0===r,last:r===x.length-1}):e));return s.createElement(m,((e,r)=>{for(var t in r||(r={}))A.call(r,t)&&R(e,t,r[t]);if(I)for(var t of I(r))P.call(r,t)&&R(e,t,r[t]);return e})({className:f(h.root,i),radius:c,p:a,component:o||"div",ref:r},d),g)}));z.Section=k,z.displayName="@mantine/core/Card"},9148:function(e,r,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/axios/interceptors",function(){return t(8384)}])},4816:function(e,r,t){"use strict";var s=(0,t(8067).k)((function(e){return{noteCard:{"&::before":{content:'""',position:"absolute",top:0,bottom:0,left:0,width:6,backgroundImage:e.fn.linearGradient(0,e.colors.yellow[6])}}}}));r.Z=s},1385:function(e,r,t){"use strict";var s=t(5893),n=t(7870);r.Z=function(e){var r=e.theme;return(0,s.jsx)(n.Z,{id:"comments",repo:"biplobmahadi/biplobmahadi.github.io",repoId:"R_kgDOHkgVOA",category:"Comments",categoryId:"DIC_kwDOHkgVOM4CQGH7",mapping:"title",term:"Welcome!",reactionsEnabled:"1",emitMetadata:"0",inputPosition:"top",theme:r,lang:"en",loading:"lazy"})}},1580:function(e,r,t){"use strict";var s=t(5893),n=t(3857),o=t(6955);r.Z=function(e){var r=e.code,t=e.language,i=(0,n.rZ)().colorScheme;return(0,s.jsx)(o.p1,{sx:{margin:"1% 0",border:"1px gray solid",borderRadius:"6px"},language:t,withLineNumbers:!0,colorScheme:"dark"===i?"dark":"light",children:r})}},8384:function(e,r,t){"use strict";t.r(r),t.d(r,{default:function(){return d}});var s=t(5893),n=t(3857),o=t(5208),i=t(1385),a=t(9008),c=t.n(a),p=t(112),l=t(1580),u=t(4816),d=function(){var e=(0,n.rZ)().colorScheme,r=(0,u.Z)().classes;return(0,s.jsxs)("div",{children:[(0,s.jsx)(c(),{children:(0,s.jsx)("title",{children:"Interceptors - Axios for React"})}),(0,s.jsxs)("div",{style:{margin:"2% 1%"},children:[(0,s.jsx)(p.x,{size:"xl",weight:700,mb:30,align:"center",children:"Axios Interceptors"}),(0,s.jsx)("section",{children:(0,s.jsx)(p.x,{size:"xs",color:"dimmed",children:"Published: Jul 28, 2022 | Last Modified: Jul 31, 2022"})}),(0,s.jsx)(p.x,{size:"sm",my:20,children:"Using axios interceptor we can intercept requests or responses before they are handled. There are 2 types of interceptor. One is a request interceptor and another is a response interceptor."}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"What does the interceptor do?"}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"Interceptor is like a middleware. If we add a request interceptor with any instance then when we call any API using that instance, that API call will go through the request interceptor before that request is made. Same for response interceptor."}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"We have our private hook."}),(0,s.jsx)(p.x,{size:"sm",weight:700,children:"hooks/usePrivateAxios.ts"}),(0,s.jsx)(l.Z,{code:'import { axiosPrivateInstance } from "../instances";\nimport axiosRequests from "../helpers/axiosRequests";\n\nexport default function usePrivateAxios() {\n  const {\n    getRequest: privateGet,\n    postRequest: privatePost,\n    putRequest: privatePut,\n    patchRequest: privatePatch,\n    deleteRequest: privateDelete,\n  } = axiosRequests(axiosPrivateInstance);\n\n  return { privateGet, privatePost, privatePut, privatePatch, privateDelete };\n}',language:"typescript"}),(0,s.jsx)(p.x,{size:"sm",mb:30,mt:20,children:"Now, we will add a request and response interceptor with our private interceptor in this private hook."}),(0,s.jsx)(p.x,{id:"requestInterceptor",weight:700,mb:20,children:"Request interceptor"}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"Using request interceptor, we will add authorization header with access token before the request made by private instance."}),(0,s.jsx)(o.Z,{className:r.noteCard,my:"lg",radius:"lg",shadow:"sm",children:(0,s.jsxs)(p.x,{size:"sm",children:["We can pass access token from any kind of memory. It can be persistent memory ",(0,s.jsx)("b",{children:"(localhost)"})," or app memory ",(0,s.jsx)("b",{children:"(state)"}),"."]})}),(0,s.jsxs)(p.x,{size:"sm",children:["Create ",(0,s.jsx)("b",{children:"interceptors/requestInterceptor.ts"})]}),(0,s.jsx)(l.Z,{code:'import { AxiosError, AxiosInstance, AxiosRequestConfig } from "axios";\n\nexport default function requestInterceptor(instance: AxiosInstance) {\n  const requestIntercept = instance.interceptors.request.use(\n    (config: AxiosRequestConfig) => {\n      if (config.headers) {\n        config.headers.Authorization = "Bearer Your_Access_Token_From_Any_Storage";\n      }\n      return config;\n    },\n    (error: AxiosError) => Promise.reject(error)\n  );\n  return requestIntercept;\n}',language:"typescript"}),(0,s.jsx)(p.x,{id:"responseInterceptor",weight:700,mt:30,mb:20,children:"Response interceptor"}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"Here we will consider a response interceptor for refresh token functionality."}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"We know, expiration time of access token is less for security purpose and refresh token expiration time is more. We always pass access token with authorization header."}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"When any request fails for authorization error then this response interceptor will create an API call to the refresh token path using refresh token and get the access token. Then that previous request will call again with the latest access token."}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"Before creating a response interceptor, let\u2019s create a hook for refresh API path."}),(0,s.jsxs)(p.x,{size:"sm",children:["Create ",(0,s.jsx)("b",{children:"hooks/useRefreshToken.ts"})]}),(0,s.jsx)(l.Z,{code:'import usePublicAxios from "./usePublicAxios";\n\nexport default function useRefreshToken() {\n  const { publicGet } = usePublicAxios();\n  const refresh = async () => {\n    const response = await publicGet(Your_Refresh_API_Path, {\n      activateAbort: false,\n    });\n\n    // You can set your new access token where you want!\n    return response;\n  };\n  return refresh;\n}',language:"typescript"}),(0,s.jsxs)(p.x,{size:"sm",mt:20,children:["Now create ",(0,s.jsx)("b",{children:"interceptors/responseInterceptor.ts"})]}),(0,s.jsx)(l.Z,{code:'import { AxiosError, AxiosInstance, AxiosResponse } from "axios";\nimport useRefreshToken from "../hooks/useRefreshToken";\n\nexport default function responseInterceptor(instance: AxiosInstance) {\n  const refresh = useRefreshToken();\n\n  const responseIntercept = instance.interceptors.response.use(\n    (response: AxiosResponse) => response,\n    async (error: AxiosError) => {\n      const { config, response } = error;\n\n      if (response?.status === 401) {\n        const newAccessToken = await refresh();\n        if (newAccessToken && config.headers) {\n          config.headers.Authorization = "Bearer Your_New_Access_Token_From_Refresh_Path";\n        }\n        return instance(config);\n      }\n      return Promise.reject(error);\n    }\n  );\n  return responseIntercept;\n}',language:"typescript"}),(0,s.jsx)(o.Z,{className:r.noteCard,my:"lg",radius:"lg",shadow:"sm",children:(0,s.jsx)(p.x,{size:"sm",children:"There is a chance for memory leak. When a request is sent with an access token and it gives an authorization error then the refresh API will call with refresh token and if that gives the correct access token then the previous API will call. And if every time that API gives authorization error, API calls will continue infinitely. So we need to stop the API call after twice."})}),(0,s.jsxs)(p.x,{size:"sm",children:["The complete ",(0,s.jsx)("b",{children:"interceptors/responseInterceptor.ts"})]}),(0,s.jsx)(l.Z,{code:'import { AxiosError, AxiosInstance, AxiosResponse } from "axios";\nimport { ICustomAxiosRequestConfig } from "../interfaces/customAxiosRequestConfig";\nimport useRefreshToken from "../hooks/useRefreshToken";\n\nexport default function responseInterceptor(instance: AxiosInstance) {\n  const refresh = useRefreshToken();\n\n  const responseIntercept = instance.interceptors.response.use(\n    (response: AxiosResponse) => response,\n    async (error: AxiosError) => {\n      const { config, response } = error;\n      let prevRequest: ICustomAxiosRequestConfig = config;\n\n      if (response?.status === 401 && !prevRequest.sent) {\n        prevRequest.sent = true;\n        const newAccessToken = await refresh();\n        if (newAccessToken && prevRequest.headers) {\n          prevRequest.headers.Authorization = "Bearer Your_New_Access_Token_From_Refresh_Path";\n        }\n        return instance(prevRequest);\n      }\n      return Promise.reject(error);\n    }\n  );\n  return responseIntercept;\n}',language:"typescript"}),(0,s.jsxs)(p.x,{size:"sm",mt:20,children:["For interface, create ",(0,s.jsx)("b",{children:"interfaces/customAxiosRequestConfig.ts"})]}),(0,s.jsx)(l.Z,{code:'import { AxiosRequestConfig } from "axios";\n\nexport interface ICustomAxiosRequestConfig extends AxiosRequestConfig {\n  sent?: boolean;\n}',language:"typescript"}),(0,s.jsx)(p.x,{id:"addingInterceptors",weight:700,mt:30,mb:20,children:"Adding interceptors with private hook"}),(0,s.jsx)(p.x,{size:"sm",mb:20,children:"We will remove interceptors when this hook will unmount from any component to avoid memory leak."}),(0,s.jsxs)(p.x,{size:"sm",children:["Here the complete ",(0,s.jsx)("b",{children:"hooks/usePrivateAxios.ts"})]}),(0,s.jsx)(l.Z,{code:'import { useEffect } from "react";\nimport requestInterceptor from "../interceptors/requestInterceptor";\nimport responseInterceptor from "../interceptors/responseInterceptor";\nimport { axiosPrivateInstance } from "../instances";\nimport axiosRequests from "../helpers/axiosRequests";\n\nexport default function usePrivateAxios() {\n  const {\n    getRequest: privateGet,\n    postRequest: privatePost,\n    putRequest: privatePut,\n    patchRequest: privatePatch,\n    deleteRequest: privateDelete,\n  } = axiosRequests(axiosPrivateInstance);\n\n  useEffect(() => {\n    const requestIntercept = requestInterceptor(axiosPrivateInstance);\n    const responseIntercept = responseInterceptor(axiosPrivateInstance);\n    return () => {\n      axiosPrivateInstance.interceptors.request.eject(requestIntercept);\n      axiosPrivateInstance.interceptors.response.eject(responseIntercept);\n    };\n  }, []);\n\n  return { privateGet, privatePost, privatePut, privatePatch, privateDelete };\n}',language:"typescript"}),(0,s.jsx)("div",{style:{marginTop:"20px"},children:(0,s.jsx)(i.Z,{theme:"dark"===e?"dark":"light"})})]})]})}}},function(e){e.O(0,[298,774,888,179],(function(){return r=9148,e(e.s=r);var r}));var r=e.O();_N_E=r}]);